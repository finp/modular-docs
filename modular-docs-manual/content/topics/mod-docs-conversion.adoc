// tag::split-mod-docs-conversion.adoc[]
[id="converting-to-mod-doc"]
= Converting to Modular Documentation

If you have a monolithic, feature-based manual, you can convert it to a set of modular content based on user stories. This conversion workflow involves using the customer product lifecycle to define user stories for your product, and creating the assemblies and modules necessary to fit each user story.

The result is documentation that is more relevant for your readers, because it is based on real-world user stories (it tells them how to accomplish their goals), and modular (it can be assembled into whatever sets and formats they might need).


.Prerequisites

* You should understand what modular documentation is:
** xref:what-modular-documentation-is[What Modular Documentation Is]
** xref:what-modular-documentation-is-not[What Modular Documentation Is Not]
** xref:modular-docs-terms-definitions[Modular Documentation Terminology]

* You should understand the benefits of modular documentation.
+
For example, see link:https://opensource.com/article/17/6/documentation-based-user-stories[_Documentation based on user stories_].

* Find a user story and practice documenting it as an xref:assembly-guidelines[assembly].
+
This process of breaking down user stories into assemblies and modules is an essential element of modular documentation. You should be familiar with this process before attempting to do it for an entire feature-based book.

* Your repository should be set up.
+
If you are using AsciiDoc, your repository should have a directory structure that supports modular documentation, and you should have a `master.adoc` file for each publication.
+
// Add an xref to Issue #4 when it's available (https://github.com/redhat-documentation/modular-docs/issues/4)


:leveloffset: +1

[id="customer-product-lifecycle"]
= Overview of the Customer Product Lifecycle

User stories are the basis of modular documentation. The modular documentation conversion workflow uses the _customer product lifecycle_ to help you discover and develop the user stories that your documentation should include.

While all products are different, everyone tends to use them in a similar workflow that starts with the initial research to determine which product to use, includes implementing and managing the product, and ends when the product is no longer needed. This customer product lifecycle can be broken down into phases, each of which presents unique user information requirements (that is, the user needs different types of information at each phase of the lifecycle):

Plan:: What information should be gathered and what decisions should be made (for example, design/deployment) before the customer can start installing the product?
Install:: How does the customer install the product on each of the supported platforms?
Configure and Verify:: After the product is installed, what does the customer need to do to configure it to work in their environment? How do they test or verify that it is ready to put into production?
Develop and Test:: Does the customer need to develop any custom applications to connect the product to any of their existing infrastructure?
Manage:: Once the product is in production, how does the customer customize and change it on a day-to-day basis?
Monitor and Tune:: Once the product is in production, how does the customer monitor its performance in order to know when changes are needed?
Upgrade and Migrate:: How does the customer upgrade to newer versions of the product?
Troubleshoot:: How does the customer fix common problems they may encounter?

:leveloffset: 1

:leveloffset: +1

[id="defining-user-stories"]
= Defining User Stories for Your Product

User stories provide the context and structure from which you can determine which assemblies and modules to create.

For more information about user stories, see xref:modular-docs-terms-definitions[Modular Documentation Terms and Definitions].

Ideally, well-defined user stories would already exist for the product you are documenting. For most writers, however, this ideal is not a reality. If you do not have any user stories from which to work, and you -- as a writer -- do not have all of the user information you would need to create the user stories yourself, how do you get started? This procedure provides a general approach that you can take.

Of course, every product differs in terms of tools, processes, team dynamics, and access to SMEs. Since you are most familiar with these aspects for your own team, you will need to adapt this general approach for your own team. Depending on your team structure, each step can be completed by either a writer or a collaboration between a writer and Content Strategist.

.Procedure

. Identify the key, top-level user stories for your product.
+
--
This step should typically be performed by the Content Strategist.

Start with the customer product lifecycle phases. If you have existing user stories, ask yourself which ones correspond to phases in the lifecycle. If you do not have existing user stories, create a user story for each lifecycle phase that applies to your product.

For more information, see xref:customer-product-lifecycle[Overview of the Customer Product Lifecycle].

For example, here is a top-level user story for the _Configure and Verify_ phase of the customer product lifecycle:

.Creating Top-Level User Stories
====
* [Phase] Configure and Verify -- [Top-level user story] As a system administrator, I want to configure _PRODUCT_ so that it is ready for production.
====
--

. Define the supporting user stories that are necessary to complete each of the top-level user stories.
+
--
This step should typically be a collaborative effort between the Content Strategist and the writer.

Each top-level user story represents a "phase" of the customer lifecycle. You should go through each phase and define the user stories needed to complete the phase. You will need to use your own knowledge and expertise of the product.

For example, for the _Configure and Verify_ phase, users would need to know how to configure and set up each component or feature of the product to work in their environment. You could break it down like this:

.Creating Second-Level User Stories
====
* As a system administrator, I want to configure _PRODUCT_ so that it is ready for production.
** As a system administrator, I want to enable _PRODUCT_ to make and accept connections so that remote peers can exchange data with _PRODUCT_.
** As a system administrator, I want to secure _PRODUCT_ so that it can communicate with remote peers securely.
** As a system administrator, I want to set up logging so that error conditions can be diagnosed.
====

At this point, you should have a two-deep list of user stories.
--

. Go back through the list and add any additional user stories that might be needed to complete any of the secondary user stories.
+
--
Depending on the product, one or two levels of user stories might be sufficient. For larger, more complex products, you might find yourself going multiple levels deep.

Be careful not to go too deep, however. At this stage, you are not defining every procedure or step needed to complete each user story. User stories represent user goals, so you should only need to go deeper if a secondary user story has multiple goals.

For example, under the "Configuring Product X" example in the previous step, the logging user story does not need any additional user stories -- the goal cannot be reduced any further than it already is. On the other hand, the adding security settings user story might be able to go a bit deeper. Security is a goal in and of itself (users want their applications to be secure), but there are more specific goals users might have within it:

.Creating Additional User Stories
====
* As a system administrator, I want to configure _PRODUCT_ so that it is ready for production.
** As a system administrator, I want to enable _PRODUCT_ to make and accept connections so that remote peers can exchange data with _PRODUCT_.
** As a system administrator, I want to secure _PRODUCT_ so that it can communicate with remote peers securely.
*** As a system administrator, I want to add security certificates so that clients can be authenticated.
*** As a system administrator, I want to use my existing LDAP configuration so that clients can be authenticated.
** As a system administrator, I want to set up logging so that error conditions can be diagnosed.
====
--

. For each user story in your list, define the following:
+
--
* What concepts does the user need to understand to complete the user story?
+
These will become the concept modules for the assembly.

* What are the procedures to complete the user story?
+
These will become the procedure modules for the assembly.

* Is there any reference information that the user might want to refer to when performing this user story?
+
These will become reference modules.

.Breaking Down User Stories
====
* As a system administrator, I want to configure _PRODUCT_ so that it is ready for production.
** As a system administrator, I want to enable _PRODUCT_ to make and accept connections so that remote peers can exchange data with _PRODUCT_.
*** Concept: Types of connections
*** Procedure: Create "listeners" to accept incoming connections
*** Procedure: Create "connectors" to connect to outbound endpoints
*** Reference: Network connection configuration attributes
** _Additional user stories..._
====
--

:leveloffset: 1

:leveloffset: +1

[id="creating-assemblies"]
= Creating Assemblies

An assembly is a representation of a user story, so you need to create an assembly for each user story that you defined.

An assembly could represent an article, "chapter" in a book, or even an entire book. However, one of the benefits of modular documentation is that you do not need to worry about how the assembly will ultimately be used -- each assembly represents a user goal, and once you create it, it can be "included" anywhere it is needed (a publication, within another assembly, and so on).

.Procedure

. Create an assembly file for each user story that you identified.
+
--
Be sure to follow the conventions for xref:anchor-and-file-names[naming anchors and files]. For example: `guided-decision-tables.adoc`
--

. For each top-level assembly file that you created, fill in the content.
+
For more information, see xref:assembly-guidelines[Assembly Guidelines].

. Repeat the previous step for each second-level assembly.

:leveloffset: 1

:leveloffset: +1

[id="creating-modules"]
= Creating Modules

After identifying and creating the assemblies, each assembly should identify the modules that you need to create.

.Procedure

. For each assembly that you created, create a module file for each module that is identified in the assembly.
+
--
Each assembly should already have the names of the modules that should be included in the assembly. Now you just need to create the actual files for those modules.

Be sure to follow the conventions for xref:anchor-and-file-names[naming anchors and files]. For example: `guided-decision-tables.adoc`
--
. For each module file that you created, add content.
+
--
Use your existing, feature-based manual to get the content. Make sure to rewrite and rework it to fit the modular documentation module templates. For more information, see:

* xref:concept-module-guidelines[Concept Module Guidelines]
* xref:procedure-module-guidelines[Procedure Module Guidelines]
* xref:reference-module-guidelines[Reference Module Guidelines]
--

:leveloffset: 1

:leveloffset: +1

[id="auditing"]
= Auditing Your Feature-Based Manual

In the process of adding content to the modules from your existing feature-based manual, it is likely that there is some existing content that did not fit into any of the user stories that you identified and thus was not pulled out. It is important to identify this content to ensure that it is no longer needed.

.Procedure

. Go through your existing feature-based manual and identify any content that you did not add to an assembly or module.

. For each piece of content that you find, determine whether it is necessary.
+
--
If the content does not fit into a user story or assembly, then it stands to reason that it may not be necessary to complete any particular user goal. If this is the case, you should be able to discard it.

.Handling Extraneous Content
====
For example, many feature-based manuals contain detailed sections about how a particular feature works. This type of content, which is valuable in certain contexts, is not always necessary for user documentation -- user goals generally involve _doing_ something, not understanding how all the details work. When you encounter this type of content, ask yourself whether a user would need to understand it to accomplish any of their goals (planning, installing, configuring, managing, and so on). If the answer is no, then you can probably discard it.
====

On the other hand, it is also possible that the content is related to a user story that you have not considered. In that case, you should create the necessary assemblies and modules and add them to your modular doc.
--

:leveloffset: 1
// end::split-mod-docs-conversion.adoc[]
