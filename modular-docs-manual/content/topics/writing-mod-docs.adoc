// tag::split-writing-mod-docs.adoc[]
[id="writing-mod-docs"]
= Writing Modular Documentation

Assemblies can include various types of modules. Use the instructions in the following sections to create modules and combine them into assemblies.


== Creating Modules

Follow these guidelines to create different types of modules:

* xref:creating-concept-modules[Concept Module]
* xref:creating-procedure-modules[Procedure Module]
* xref:reference-module-guidelines[Reference Module]

See <<appendix-examples>> for real-world examples of assemblies, modules, and their individual parts.

:leveloffset: +2

[id="creating-concept-modules"]
= Creating Concept Modules

This section explains what a concept module is and provides recommended practices for writing concept modules.

:leveloffset: +1

[id="concept-module-definition"]
= Concept Module Definition

A concept module is an "understand" module. Concept modules give the user descriptions and explanations needed to understand and use a product.

:leveloffset: 1

:leveloffset: +1

[id="concept-module-guidelines"]
= Concept Module Guidelines

The core requirement for a concept module is explaining the idea, or concept.
A concept module requires a short introduction and optionally, can also include additional resources.

When planning a concept module, look at nouns in related procedure modules and assemblies to find the concepts to explain to users.
Explain only things that are visible to users.
Even if a concept is interesting, it probably does not require an explanation if it is not visible to users.

image::concept-diagram.png[]

[discrete]
== Concept Introduction

The introduction to a concept module is a single, concise paragraph that provides a short overview of the module.
A short description makes the module more usable because users can quickly determine whether the concept is useful without having to read the entire module.

The introduction typically answers the following questions:

* What is the concept?
* Why should the user care about the concept?

[discrete]
== Concept Body

The concept body describes the subject of the concept module.

Apart from paragraphs, you can use other AsciiDoc elements, such as lists, tables, or examples.
Consider including graphics or diagrams to speed up the understanding of the concept.

Do not include any instructions to perform an action, such as executing a command.
Action items belong in procedure modules.
See also link:http://www.informationmapping.com/fspro2013-tutorial/infotypes/infotype2.html[The Six Information Types] at _informationmapping.com_ for ways to present different types of conceptual information: principle, concept, structure, process, fact.

[discrete]
== Concept Additional Resources

The optional additional resources list links to other material closely related to the contents of the concept module, for example, other documentation resources.
Because of current tooling limitations, you cannot include xref links to other content in your collection in the concept module.
You can include xref links in the assembly that contains the concept.

Focus on relevant resources that are likely to be of immediate interest to the user. Do not list resources for completeness.

:leveloffset: 1

== Additional Resources

* Download the link:https://raw.githubusercontent.com/redhat-documentation/modular-docs/master/modular-docs-manual/files/TEMPLATE_CONCEPT_concept-explanation.adoc[concept module template (adoc file)] for new projects.
* For real-world examples of concept modules, see <<modular-docs-concept-examples>>.

:leveloffset: 1

:leveloffset: +2

[id="creating-procedure-modules"]
= Creating Procedure Modules

This section explains what a procedure module is and provides recommended practices for writing procedure modules.

:leveloffset: +1

[id="procedure-module-definition"]
= Procedure Module Definition

A procedure module is a "do" module. It gives the user numbered, step-by-step instructions.

IMPORTANT: A procedure module does not consist solely of a procedure. At the very least, the steps must be preceded by an introductory statement that provides context for the procedure. For details, see <<procedure-module-guidelines>>.

:leveloffset: 1

:leveloffset: +1

[id="procedure-module-guidelines"]
= Procedure Module Guidelines

The required parts of a procedure module are a procedure and its introduction. Optionally, the module can also include prerequisites and additional resources.

.Schema of a procedure module
image::procedure-diagram.png[]

[discrete]
== Procedure Introduction
The introduction is a short description of the procedure. For example, it can be a lead-in sentence or an infinitive phrase (_To extract the certificate: <steps>_). See also _The IBM Style Guide_ footnoteref:[ibm-style-guide,DERESPINIS, Francis, Peter HAYWARD, Jana JENKINS, Amy LAIRD, Leslie McDONALD, Eric RADZINKSI. _The IBM style guide: conventions for writers and editors_. Upper Saddle River, NJ: IBM Press/Pearson, c2012. ISBN 0132101300.] for details on introducing procedures.

The introduction typically provides context for the procedure, such as:

* Who is the user performing the procedure
* Why and where the user performs the procedure
* Special considerations specific to the procedure

Keep the information brief and focused on what the user needs for this specific procedure. Suggested length is 1--3 sentences, but it can be longer.

[discrete]
== Procedure Prerequisites
Prerequisites are conditions that must be satisfied before the user starts the procedure. If a prerequisite is a procedure or an assembly, include a link to them. See also _The IBM Style Guide_ footnoteref:[ibm-style-guide] for details on writing prerequisites.

Focus on relevant prerequisites that users might not otherwise be aware of. Do not list obvious prerequisites.

Use a bulleted list for prerequisites, even if you only have a single prerequisite.

[discrete]
== Procedure Body
The procedure consists of one or more steps required to complete the procedure. Each step describes one action.

For single-step procedures, use an unnumbered bullet instead of a numbered list.

[discrete]
== Procedure verification steps
This section is optional. Provide the user with one or more steps to verify that the procedure provided the intended outcome. This may consist of:

- An example of expected command output or 'pop-up' window the user should receive when the procedure is successful.
- An 'action' (or 'actions') for the user, such as running a command, to determine the success or failure of the procedure.

[discrete]
== Procedure Additional Resources

The optional additional resources list links to other material closely related to the contents of the procedure module, for example, other documentation resources, instructional videos, or labs.
Because of current tooling limitations, you cannot include xref links to other content in your collection in the procedure module.
You can include xref links in the assembly that contains the procedure.

Focus on relevant resources that are likely to be of immediate interest to the user. Do not list resources for completeness.

:leveloffset: 1

== Additional Resources

* Download the link:https://raw.githubusercontent.com/redhat-documentation/modular-docs/master/modular-docs-manual/files/TEMPLATE_PROCEDURE_doing-one-procedure.adoc[procedure module template (adoc file)] for new projects.
* For real-world examples of procedure modules, see <<modular-docs-procedure-examples>>.

:leveloffset: 1

:leveloffset: +2

[id="creating-reference-modules"]
= Creating Reference Modules

This section explains what a reference module is and provides recommended practices for writing reference modules.

:leveloffset: +1

[id="reference-module-definition"]
= Reference Module Definition

Reference modules provide data that users might want to look up, but do not need to remember.

.Common documentation examples of reference modules
====
* A list of commands that users can use with an application
* A table of configuration files with definitions and usage examples
* A list of default settings for a product
====

.Reference modules explained using a real-life example
====
For documentation on how to cross the road, you could create these modules:

* Concept modules:
** What are roads
** What are crossings

* Procedure modules:
** How to put one foot in front of another
** How to use pedestrian traffic lights
** How to see if the road is clear for crossing

* Reference modules:
** Crossing signals
** Common crosswalk pavement markings
** Crossing laws by country
====

:leveloffset: 1

:leveloffset: +1

[id="reference-module-guidelines"]
= Reference Module Guidelines

The required part of a reference module is the reference data.
A reference module requires a short introduction.

[discrete]
== Reference Introduction

The introduction to a reference module is a single, concise paragraph that provides a short overview of the module. A short description makes the module more usable because users can quickly determine whether the reference is useful without having to read the entire module.

[discrete]
== Reference Body

A reference module has a very strict structure, often in the form of a list or a table. A well-organized reference module enables users to scan it quickly to find the details they want.

To make the reference data easier to scan, organize it in a logical order (such as alphabetically) or as a table. AsciiDoc markup to consider for reference data:

* link:http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/#lists[Lists] (unordered, labeled)
* link:http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/#tables[Tables]

If you have a large volume of the same type of information to document, use a structure into which the information details can fit, and then document each logical unit of information as one reference module. For example, think of man pages, which document very different information details, but which still use consistent titles and formats to present those details in a uniform information structure.

:leveloffset: 1

== Additional Resources

* Download the link:https://raw.githubusercontent.com/redhat-documentation/modular-docs/master/modular-docs-manual/files/TEMPLATE_REFERENCE_reference-material.adoc[reference module template (adoc file)] for new projects.
* For real-world examples of reference modules, see <<modular-docs-reference-examples>>.
* For advice on when to use lists and when to use tables, see link:https://medium.com/@heyoka/lets-bring-table-to-the-table-again-f1ae751159d5[Letâ€™s bring <table> to the table, again.]

:leveloffset: 1

:leveloffset: +2

// Module included in the following assemblies:
//
// <List assemblies here, each on a new line>

// Base the file name and the ID on the module title. For example:
// * file name: my-concept-module-a.adoc
// * ID: [id="my-concept-module-a-{context}"]
// * Title: = My concept module A

// The ID is used as an anchor for linking to the module. Avoid changing it after the module has been published to ensure existing links are not broken.
[id="using_text_snippets_or_text_fragments-{context}"]
// The `context` attribute enables module reuse. Every module's ID includes a variable that sets the context, such as {context}, which ensures that the module has a unique ID even if it is reused multiple times in a guide.
= Text Snippets or Text Fragments (Pseudo-modules)
//In the title of concept modules, include nouns or noun phrases that are used in the body text. This helps readers and search engines find the information quickly.
//Do not start the title of concept modules with a verb. See also _Wording of headings_ in _The IBM Style Guide_.

[NOTE]
The following standard is recommended when the documentation is being maintained without a Content Management System (CMS) capable of managing complex interrelations between modules.

The use of reusable text snippet files (or text fragment files) is discouraged due to the complications that can arise due to the complexity they introduce.

Snippet (fragment) file use should be limited to:

* Standardized admonitions (such as 'Technology preview' and 'Beta' text).
* Where there is an existing standard between the upstream and downstream communities.


//.Additional resources

//* A bulleted list of links to other material closely related to the contents of the concept module.

:leveloffset: 1

:leveloffset: +2

[id="anchor-and-file-names"]
= Anchor Names and File Names

To optimize modular documentation, follow these guidelines for naming module anchors and files:

Anchor names:: Provide an anchor in the format `+++[id="anchor-name-{context}"]+++` for every module so that it can be identified by Asciidoctor when reused or cross-referenced. `+++{context}+++` is a variable whose value you define in the assembly. Give the anchor the same or similar name as the module heading. Separate the words in the anchor with hyphens:
+
--
[source]
----
[id="anchor-name-{context}"]
= Module Heading

The first sentence of the topic.
----

.Example 1. Concept Module
[source]
----
[id="guided-decision-tables-{context}"]
= Guided Decision Tables

The guided decision tables feature works similarly to ...
----

.Example 2. Procedure Module
[source]
----
[id="creating-guided-decision-tables-{context}"]
= Creating Guided Decision Tables

You can use guided decision tables to ...
----

[NOTE]
.Note on Other Anchor Formats (Not Recommended)
====
The format defined here is recommended because it is the most stable and versatile of anchor formats, and supports variables that enable topics to be reused and cross-referenced properly. For details, see xref:reusing-modules[]. Other anchor formats include `+++[[anchor-name]]+++` and `+++[#anchor-name]+++`, but these formats either do not support variables for content reuse or do not support certain character types, such as periods. These limitations cause errors at build time.
====

For more information about Asciidoc anchors, see the link:http://asciidoctor.org/docs/user-manual/#anchordef[Asciidoctor User Manual].
--

File names:: Give the module file the same name as the anchor used in it (which is the same as or similar to the module heading). Assembly and module file names should accurately and closely reflect the title of the assembly or module.
+
[NOTE]
====
Ensure that all members of your team use the same file naming conventions.
====
+
.Examples
* `guided-decision-tables.adoc`  (Concept module)
* `creating-guided-decision-tables.adoc`  (Procedure module for creating)
* `editing-guided-decision-tables.adoc`  (Procedure module for editing)
* `guided-decision-table-examples.adoc`  (Reference module with examples)
* `guided-decision-table-columns.adoc`  (Reference module with column types)
* `designing-guided-decision-tables.adoc`  (Assembly of guided decision table modules)

.Additional Resources

* The link:http://asciidoctor.org/docs/user-manual/#anchordef[Asciidoctor User Manual]

:leveloffset: 1

:leveloffset: +1

[id="forming-assemblies"]
= Forming Assemblies

This section explains what an assembly is and provides recommended practices for forming assemblies.

:leveloffset: +1

[id="assembly-definition"]
= Assembly Definition

An assembly is a collection of modules that describes how to accomplish a user story. See also <<understanding-mod-docs>>.

:leveloffset: 1

:leveloffset: +1

[id="assembly-guidelines"]
= Assembly Guidelines

The required parts of an assembly are the introduction and modules. Optionally, an assembly can also include prerequisites and additional resources.

[discrete]
== Assembly Introduction

The introduction explains what the user accomplishes by working through the assembled modules. It typically provides context for the assembly.

Consider rewording the user story to write the assembly introduction, for example:

* User story: As an administrator, I want to provide external identity, authentication and authorization services for my Atomic Host, so that users from external identity sources can access the Atomic Host.
* Assembly introduction: As a system administrator, you can use SSSD in a container to provide external identity, authentication, and authorization services for the Atomic Host system. This enables users from external identity sources to authenticate to the Atomic Host.

[discrete]
== Assembly Prerequisites

Prerequisites are conditions that must be satisfied before the user can start following the assembly.

// [bhardest] - We have a lot of xref-ing in these guidelines. A better approach might be to create a "snippets" .adoc file with snippets of common content (for example, the content about writing prerequisites, which applies to multiple sections). Then we can just include the relevant content from the snippets file wherever it's needed.
// [asteflova] - Let's do this after we finish reviewing the guidelines for procedures and assemblies.
// [sterobin] - I removed the cross-ref to the procedure "Writing prerequisites" for now because it provided no value and the id for that linked section needed to be removed anyway (should only be linking to modules, not module sub-headings). This clearly now provides little information, but based on the above comments, we should be looking into a better structure all around in this doc for describing the prereq, intro, body components that apply universally.

[discrete]
== Assembly Modules

List link:http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/#include-files[include files] to include the required modules. Use any combination of concept, procedure, and reference modules that fulfills the purpose of the assembly.

[discrete]
== Assembly Additional Resources

The optional additional resources list links to other material closely related to the contents of the assembly, for example, other documentation resources, instructional videos, or labs.

Focus on relevant resources that are likely to be of immediate interest to the user. Do not list resources for completeness.

:leveloffset: 1

== Additional Resources

* Download the link:https://raw.githubusercontent.com/redhat-documentation/modular-docs/master/modular-docs-manual/files/TEMPLATE_ASSEMBLY_a-collection-of-modules.adoc[assembly template (adoc file)] for new projects.
* For real-world examples of assemblies, see <<modular-docs-assembly-examples>>.

:leveloffset: 1

:leveloffset: +2

[id="reusing-modules"]
= Reusing Modules in Assemblies

When you create content in modules, you can use the same module multiple times in an assembly without having to replicate information in multiple source files. However, in order to facilitate module reuse, you must embed a document attribute variable in the anchor name for the module and then define that variable in the assembly each time the reused module appears. If the variable is not embedded and assigned, an error appears at build time reporting the duplicated anchor ID.

.Error at Build Time When Anchor Has No Variable
====
[source]
----
ID "$ANCHOR_NAME" is duplicated in the source content
$BUILD_PATH fails to validate
----
====

This error is resolved by adding and defining a document variable.

[discrete]
.Procedure

. In the module file that will be reused, add the `+++{context}+++` suffix with a hyphen to the anchor name in the format `[id="anchor-name-+++{context}"+++]`.
+
NOTE: Although you can use any document variable that clearly indicates the variable in question, such as `+++{product}+++` or `+++{chapter}+++`, the `+++{context}+++` variable is recommended. This variable indicates more generally that the same module can be reused in the specified "context" of one section of a document or another, regardless of whether that section is product-specific or not, whether it is a whole chapter or a small assembly, or some other limitation.

+
.Two Modules to Be Reused: Module A and Module B
[source]
----
[id="module-A-being-reused-{context}"]
= Module A Heading
----
+
[source]
----
[id="module-B-being-reused-{context}"]
= Module B Heading
----

 . In the assembly file or the master book file, define the `+++:context:+++` variable immediately above any included modules that are being reused, in the format `+++:context:+++ variable-name`. How you define the variable depends on whether the module is included once in multiple assemblies or is included multiple times in a single assembly. Note that the `+++:context:+++` variable definition uses hyphens to separate its terms.
+
Module Included Once in Multiple Assemblies:: If the reused modules are included only once in this assembly and in at least one other assembly, define an assembly-level variable such as `+++:context: assembly-name+++`. This  indicates that the reused module is appearing in the context of that assembly.

+
.Assembly 1
[source]
----
\include::some-module-not-being-reused.adoc

:context: assembly-1-name
\include::module-A-being-reused.adoc

\include::some-module-not-being-reused.adoc

:context: assembly-1-name
\include::module-B-being-reused.adoc
----

+
.Assembly 2
[source]
----
\include::some-module-not-being-reused.adoc

:context: assembly-2-name
\include::module-A-being-reused.adoc

\include::some-module-not-being-reused.adoc

:context: assembly-2-name
\include::module-B-being-reused.adoc
----

+
Module Included Multiple Times in a Single Assembly:: If a module is included multiple times in the same assembly, define a variable specific to a section or a chapter of that assembly, such as `+++:context: section-name+++`. This  indicates that the reused module is appearing in the context of that section of the assembly.

+
.Assembly
[source]
----
\include::some-module-not-being-reused.adoc

:context: section-1-name
\include::module-A-being-reused.adoc

\include::some-module-not-being-reused.adoc

:context: section-2-name
\include::module-A-being-reused.adoc
----

+
. Return to the reused module file, and at the top of the file add a comment that identifies which assemblies the module has been added to. This helps to track reused modules in the future.

+
[source]
----
// Module included in the following assemblies:
//
// ...

[id="module-A-being-reused-{context}"]
= Module A Heading
----

////
.Cross-Referencing Reused Modules
[NOTE]
====
To cross-reference a reused module, specify both the anchor name and the `+++{context}+++` variable as defined in the assembly:

[source]
----
xref:anchor-name_context-variable-name[]
----

Example:

[source]
----
For details, see xref:module-A-being-reused_assembly-1-name[].
----
====
////

.Additional Resources

* The link:http://asciidoctor.org/docs/user-manual/#include-multiple[Asciidoctor User Manual].

// [sterobin] - I need to rework the two "Practical Examples" below to be stand-alone modules. Good candidates for reuse.

[discrete]
== Practical Example 1: Reusing Modules in Multiple Assemblies

You want to reuse the "Creating Assets" procedure module and the "Projects" concept module in two assemblies: an "Asset Definitions" assembly and a "Business Rules" assembly.

The module files contain the following content:

.projects.adoc
[source]
----
// Module included in the following assemblies:
//
// asset-definitions.adoc
// business-rules.adoc

[id="projects-{context}"]
= Projects
----

.creating-assets.adoc
[source]
----
// Module included in the following assemblies:
//
// asset-definitions.adoc
// business-rules.adoc

[id="creating-assets-{context}"]
= Creating Assets
----

The assembly files contain the following content:

.asset-definitions.adoc
[source]
----
\include::organizational-unit.adoc

\include::repository.adoc

:context: asset-definitions
\include::projects.adoc

\include::organizational-unit.adoc

\include::creating-packages.adoc

:context: asset-definitions
\include::creating-assets.adoc

\include::adding-dependencies.adoc
----

.business-rules.adoc
[source]
----
\include::business-processes.adoc

:context: business-rules
\include::projects.adoc

\include::project-types.adoc

\include::packages.adoc

:context: business-rules
\include::creating-assets.adoc
----

For all cross-references to the reused modules, specify which context (assembly) you want to link to. For example, you can link to the "Creating Assets" procedure module as it appears either in the "Asset Definitions" assembly or in the "Business Rules" assembly. Create cross-references in the `+++xref:anchor-name_context-variable-name[]+++` format:

[source]
----
For details, see xref:creating-assets_asset-definitions[].
----

or

[source]
----
For details, see xref:creating-assets_business-rules[].
----

[discrete]
== Practical Example 2: Reusing a Module in a Single Assembly

You want to reuse the "Projects" concept module twice in the "Business Rules" assembly.

The module file contains the following content:

.projects.adoc
[source]
----
[id="projects-{context}"]
= Projects
----

The assembly file contains the following content:

.business-rules.adoc
[source]
----
:context: intro
\include::projects.adoc

\include::organizational-unit.adoc

\include::asset-types.adoc

:context: asset-types
\include::projects.adoc

\include::dependencies.adoc
----

For all cross-references to the reused module, specify which context (section) you want to link to. For example, you can link to the "Projects" module as it appears either in the "Introduction" or in the "Asset Types" section. You create cross-references in the format `+++xref:anchor-name_context-variable-name[]+++`:

[source]
----
For details, see xref:projects_introduction[].
----

or

[source]
----
For details, see xref:projects_asset-types[].
----

:leveloffset: 1

:leveloffset: +2

[id="nesting-assemblies"]
= Nesting Assemblies in Assemblies

When you set the `:context:` variable in an assembly, the variable continues to be set to the same value in the rest of the document even after the assembly itself ends. This causes problems if you include an assembly in another assembly.

If there is, for example, an _Additional Resources_ section in the inner, included assembly as well as in the outer, including assembly after the include statements, the ID of the second one gets overwritten with the `:context:` variable of the included assembly. This causes duplicate IDs, which lead to build-time errors like:

----
asciidoctor: WARNING: 1.adoc: line 19: id assigned to section already in use: additional-resources-2
----

.Nested Assemblies with a Duplicate ID
====
image::nested-assemblies-error.png[alt=Nested Assemblies with a Duplicate ID,width=500]
====

To solve this problem, restore the `:context:` variable to its previous value when assemblies end:

. Add the following line at the top of your assemblies before `:context:` is defined to save the inherited context:
+
[source,asciidoc]
----
----

. Add the following lines to the end of your assemblies to restore the saved context, if one already existed:
+
[source,asciidoc]
----
:!context:
----

.Correctly Nested Assemblies
====
image::nested-assemblies-correct.png[alt=Correctly Nested Assemblies,width=500]
====

See also the link:https://raw.githubusercontent.com/redhat-documentation/modular-docs/master/modular-docs-manual/files/TEMPLATE_ASSEMBLY_a-collection-of-modules.adoc[assembly template] for an example.


:leveloffset: 1
// end::split-writing-mod-docs.adoc[]
